# GeekBrainsMessageDrivenArchitecture

## Урок 1

* Создать возможность снять бронь синхронно и асинхронно, используя для этого
номер забронированного стола;
* Выделить логику для отправки уведомления в отдельный класс, он будет
отвечать за все вопросы связанные с коммуникациями с клиентами, добавить
задержку (они будет имитировать создание сообщения) и сделать вызов
уведомления асинхронным;
* Добавить автоматическое “снятие брони”. Например, раз в 20 секунд при
наличии забронированных мест - бронь должна слетать. Асинхронно, независимо
от ввода-вывода. Подсказка: можно использовать таймер.
* (*) Добавить синхронизацию бронирований для множественных асинхронных и
синхронных вызовов, это значит, что бронируя столики не дожидаясь
предыдущих ответов мы должны получать последовательный результат.
* (**) Добавить ограничение на количество мест за столом относительно
количества гостей, например, если придет 5 человек, то сесть можно только за
стол где больше 5 мест. Столы сдвигать можно. Должна быть синхронизация
между разными одновременными бронированиями.

## Урок 3

Используя весь опыт предыдущих уроков и код из методички воспроизвести
приложение описанное в тексте материала;
● Добавить в сервис кухни неожиданные поломки или попадание блюд в стоп-лист,
которые вызывают реакцию в других сервисах: отправляется уведомление о
снятии брони с извинениями и происходит снятие бронирования. Никаких прямых
команд между сервисами быть не должно, только данные в публикациях на
которые будут реагировать остальные сервисы.
● (*) Добавить возможность отправлять сообщение через обменник с типом direct
из сервиса бронирований на кухню с синхронным ожиданием ответа. Для этого
придется использовать заголовки и конфигурацию. Сообщение должно
содержать следующий смысл “Когда обед?”. Кухня может отвечать от 0,5 до 3
секунд любым сообщением. Если время ответа превышает 1,5 секунд в более
чем 10 случаев из последних 30 - необходимо чтобы срабатывал шаблон
“Предохранитель”.
